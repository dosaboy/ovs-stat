#!/bin/bash -u
TRAP_ERROR_MSG="failed to get bridge ports"

# lib
for l in `find $CWD/common -type f`; do source $l; done

__get_port_info ()
{
    local of_id=$1
    local of_port=$2
    local mac=$3
    local bridge=$4
    local name

    # Ports that have this mac address are likely attached to a network
    # namespace (ovs 2.9) so attempt to get mac from there. Note that this is
    # only expected for ports directly attached and not via a veth pair.
    if [[ $mac == "00:00:00:00:00:00" ]]; then
        name=`get_ovsdb_client_list_dump| egrep -B 5 "ofport\s+: $of_id"| awk '$1=="name" {print $3}'| tr -d '"'`
        # won't be visible outside of ns so have to search all
        ns_name="`get_ns_ip_addr_show_all| egrep "netns:|$name"| grep -B 1 $name| head -n 1`"
        ns_name=${ns_name##netns: }
        # attempt to get port mac from namespace
        if [ -n "$ns_name" ]; then
            mac="`get_ns_ip_addr_show $ns_name| \
                  grep -A 1 "$name:"| \
                  sed -rn 's,.+link/ether\s+([[:alnum:]\:]+)\s+.+,\1,p'`"
        fi
        # else just ignore and use ovs mac
    else
        # ensure bridge is not included in returned value
        name=`get_ovsdb_client_list_dump| grep -A 5 "$mac"| awk '$1=="name" {print $3}'| egrep -v "^$bridge$"| tr -d '"'`
    fi

    if [ -z "$name" ]; then
        echo "INFO: unable to resolve name of port with id $of_id mac $mac on $bridge - skipping port"
        return 0
    fi

    mkdir -p $RESULTS_PATH_HOST/ovs/ports/$name
    ln -s ../../bridges/$bridge \
        $RESULTS_PATH_HOST/ovs/ports/$name/bridge
    ln -s ../../../ports/$name \
        $RESULTS_PATH_HOST/ovs/bridges/$bridge/ports/$of_id
    echo $of_id > $RESULTS_PATH_HOST/ovs/ports/$name/id

    # is it actually a linux port - create fwd and rev ref
    if `get_ip_link_show| grep -q $name`; then
        mkdir -p $RESULTS_PATH_HOST/linux/ports/$name
        ln -s ../../../linux/ports/$name \
            $RESULTS_PATH_HOST/ovs/ports/$name/hostnet
        ln -s ../../../ovs/ports/$name \
            $RESULTS_PATH_HOST/linux/ports/$name/ovs
    fi

    echo $mac > $RESULTS_PATH_HOST/ovs/ports/$name/hwaddr
}

__load_bridge_ports ()
{
    # loads all ports on all bridges
    #
    # NOTE: if a non-existant port is attached to a bridge it will show in
    #       ovs-vsctl but not ovs-ofctl. We use the latter here so if port is
    #       missing from the dataset it is because it could not be found by
    #       ovs.
    # TODO: should x-ref with ovs-vsctl list-ports <bridge> so that we have a
    #       way to alert.
    local current_jobs=0
    local mac
    local port_of_id
    local name

    for bridge in `ls $RESULTS_PATH_HOST/ovs/bridges`; do
        current_jobs=0
        mkdir -p $RESULTS_PATH_HOST/ovs/bridges/$bridge/ports

        # we list ports my mac since that is known to be unique (port names
        # can be abridged).
        readarray -t ports<<<"`get_ovs_ofctl_show $bridge| grep -v LOCAL| \
            sed -rn 's/^\s+([[:digit:]]+)\((.+)\):\s+addr:(.+)/\1 \2 \3/p'`"

        ((${#ports[@]})) && [ -n "${ports[0]}" ] || continue
        for port in "${ports[@]}"; do
            port_of_id=`echo $port| cut -d ' ' -f 1`
            name=`echo $port| cut -d ' ' -f 2`
            mac=`echo $port| cut -d ' ' -f 3`
            __get_port_info $port_of_id $name $mac $bridge &
            job_wait $((++current_jobs)) && wait
        done
        wait
    done
}

# main()
__load_bridge_ports 2>$RESULTS_PATH_HOST/error.$$

